#!/usr/bin/env bash

#######################################
#    simulate_dyngen_dataset 1.1.0    #
#######################################

# This wrapper script is auto-generated by viash 0.5.2 and is thus a derivative
# work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
# Intuitive.  The component may contain files which fall under a different
# license. The authors of this component should specify the license in the
# header of such files, or include a separate license file detailing the
# licenses of all included files.
#
# Component authors:
# * Robrecht Cannoodt <rcannood@gmail.com> (author, maintainer) {github: rcannood, orcid: 0000-0003-3641-729X}

set -e

if [ -z "$VIASH_TEMP" ]; then
  VIASH_TEMP=/tmp
fi

# define helper functions
# ViashQuote: put quotes around non flag values
# $1     : unquoted string
# return : possibly quoted string
# examples:
#   ViashQuote --foo      # returns --foo
#   ViashQuote bar        # returns 'bar'
#   Viashquote --foo=bar  # returns --foo='bar'
function ViashQuote {
  if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
    echo "$1" | sed "s#=\(.*\)#='\1'#"
  elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
    echo "$1"
  else
    echo "'$1'"
  fi
}
# ViashRemoveFlags: Remove leading flag
# $1     : string with a possible leading flag
# return : string without possible leading flag
# examples:
#   ViashRemoveFlags --foo=bar  # returns bar
function ViashRemoveFlags {
  echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
}
# ViashSourceDir: return the path of a bash file, following symlinks
# usage   : ViashSourceDir ${BASH_SOURCE[0]}
# $1      : Should always be set to ${BASH_SOURCE[0]}
# returns : The absolute path of the bash file
function ViashSourceDir {
  SOURCE="$1"
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
}
VIASH_VERBOSITY=5

# see https://en.wikipedia.org/wiki/Syslog#Severity_level

# ViashLog: Log events depending on the verbosity level
# usage: ViashLog 1 alert Oh no something went wrong!
# $1: required verbosity level
# $2: display tag
# $3+: messages to display
# stdout: Your input, prepended by '[$2] '. 
function ViashLog {
  local required_level="$1"
  local display_tag="$2"
  shift 2
  if [ $VIASH_VERBOSITY -ge $required_level ]; then
    echo "[$display_tag]" "$@"
  fi
}

# ViashEmergency: log events when the system is unstable
# usage: ViashEmergency Oh no something went wrong.
# stdout: Your input, prepended by '[emergency] '. 
function ViashEmergency {
  ViashLog 0 emergency $@
}

# ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
# usage: ViashAlert Oh no something went wrong.
# stdout: Your input, prepended by '[alert] '. 
function ViashAlert {
  ViashLog 1 alert $@
}

# ViashCritical: log events when a critical condition occurs
# usage: ViashCritical Oh no something went wrong.
# stdout: Your input, prepended by '[critical] '. 
function ViashCritical {
  ViashLog 2 critical $@
}

# ViashError: log events when an error condition occurs
# usage: ViashError Oh no something went wrong.
# stdout: Your input, prepended by '[error] '. 
function ViashError {
  ViashLog 3 error $@
}

# ViashWarning: log potentially abnormal events
# usage: ViashWarning Something may have gone wrong.
# stdout: Your input, prepended by '[warning] '. 
function ViashWarning {
  ViashLog 4 warning $@
}

# ViashNotice: log significant but normal events
# usage: ViashNotice This just happened.
# stdout: Your input, prepended by '[notice] '. 
function ViashNotice {
  ViashLog 5 notice $@
}

# ViashInfo: log normal events
# usage: ViashInfo This just happened.
# stdout: Your input, prepended by '[info] '. 
function ViashInfo {
  ViashLog 6 info $@
}

# ViashDebug: log all events, for debugging purposes
# usage: ViashDebug This just happened.
# stdout: Your input, prepended by '[debug] '. 
function ViashDebug {
  ViashLog 7 debug $@
}

# find source folder of this component
VIASH_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`


# ViashHelp: Display helpful explanation about this executable
function ViashHelp {
  echo "simulate_dyngen_dataset 1.1.0"
  echo "Generate a synthetic dataset using the standard dyngen simulation workflow."
  echo "For more advanced usage to get more control over the outputted dataset, use the"
  echo "R package. More documentation can be found at https://dyngen.dynverse.org."
  echo
  echo "Options:"

  echo "   --id"
  echo "        type: string, required parameter"
  echo "        example: dyngen_dataset"
  echo "        The id of the output dataset id"
  echo ""


  echo "   --reference_rna"
  echo "        type: file"
  echo "        example: input_rna_reference.h5ad"
  echo "        A reference RNA dataset."
  echo ""


  echo "   --reference_mod2"
  echo "        type: file"
  echo "        example: input_mod2_reference.h5ad"
  echo "        A reference mod2 dataset."
  echo ""


  echo "   --output_rna"
  echo "        type: file, required parameter, output"
  echo "        example: output_rna.h5ad"
  echo "        Output h5ad RNA file."
  echo ""


  echo "   --output_mod2"
  echo "        type: file, required parameter, output"
  echo "        example: output_mod2.h5ad"
  echo "        Output h5ad modality2 file (ATAC or Antibody capture)."
  echo ""


  echo "   -p, --plot"
  echo "        type: file, required parameter, output"
  echo "        example: plot.pdf"
  echo "        A visualisation of the simulation."
  echo ""


  echo "   --num_cells"
  echo "        type: integer"
  echo "        default: 100"
  echo "        The number of cells to generate."
  echo ""


  echo "   --num_genes"
  echo "        type: integer"
  echo "        default: 100"
  echo "        The number of genes to generate."
  echo ""


  echo "   --num_simulations"
  echo "        type: integer"
  echo "        default: 32"
  echo "        The number of dyngen simulations to run."
  echo ""


  echo "   --census_interval"
  echo "        type: double"
  echo "        default: 4.0"
  echo "        A granularity parameter for the outputted simulation."
  echo ""


  echo "   --ssa_tau"
  echo "        type: double"
  echo "        default: 0.008333"
  echo "        Step size of the GillespieSSA2 simulation. Default is 30/3600."
  echo ""


  echo "   -chromatin, --store_chromatin"
  echo "        type: boolean_true"
  echo "        Whether or not to compute chromatin accessibility data."
  echo ""


  echo "   -protein, --store_protein"
  echo "        type: boolean_true"
  echo "        Whether or not to store protein count information."
  echo ""


  echo "   --num_threads"
  echo "        type: integer"
  echo "        default: 1"
  echo "        Parallellisation level."
  echo ""


  echo "   --seed"
  echo "        type: integer"
  echo "        Seed"
  echo ""


  echo "   --cache_dir"
  echo "        type: file"
  echo "        A caching directory for files that dyngen downloads."
  echo ""

}
######## Helper functions for setting up Docker images for viash ########


# ViashDockerRemoteTagCheck: check whether a Docker image is available 
# on a remote. Assumes `docker login` has been performed, if relevant.
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerRemoteTagCheck python:latest
#   echo $?                                     # returns '0'
#   ViashDockerRemoteTagCheck sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerRemoteTagCheck {
  docker manifest inspect $1 > /dev/null 2> /dev/null
}

# ViashDockerLocalTagCheck: check whether a Docker image is available locally
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   docker pull python:latest
#   ViashDockerLocalTagCheck python:latest
#   echo $?                                     # returns '0'
#   ViashDockerLocalTagCheck sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerLocalTagCheck {
  [ -n "$(docker images -q $1)" ]
}

# ViashDockerPull: pull a Docker image
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerPull python:latest
#   echo $?                                     # returns '0'
#   ViashDockerPull sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerPull {
  ViashNotice "Running 'docker pull $1'"
  docker pull $1 && return 0 || return 1
}

# ViashDockerPullElseBuild: pull a Docker image, else build it
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
# examples:
#   ViashDockerPullElseBuild mynewcomponent
function ViashDockerPullElseBuild {
  set +e
  ViashDockerPull $1
  out=$?
  set -e
  if [ $out -ne 0 ]; then
    ViashDockerBuild $@
  fi
}

# ViashDockerSetup: create a Docker image, according to specified docker setup strategy
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# $2                  : docker setup strategy, see DockerSetupStrategy.scala
# ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
# examples:
#   ViashDockerSetup mynewcomponent alwaysbuild
function ViashDockerSetup {
  VSHD_ID="$1"
  VSHD_STRAT="$2"
  if [ "$VSHD_STRAT" == "alwaysbuild" -o "$VSHD_STRAT" == "build" -o "$VSHD_STRAT" == "b" ]; then
    ViashDockerBuild $VSHD_ID --no-cache
  elif [ "$VSHD_STRAT" == "alwayspull" -o "$VSHD_STRAT" == "pull" -o "$VSHD_STRAT" == "p" ]; then
    ViashDockerPull $VSHD_ID
  elif [ "$VSHD_STRAT" == "alwayspullelsebuild" -o "$VSHD_STRAT" == "pullelsebuild" ]; then
    ViashDockerPullElseBuild $VSHD_ID --no-cache
  elif [ "$VSHD_STRAT" == "alwayspullelsecachedbuild" -o "$VSHD_STRAT" == "pullelsecachedbuild" ]; then
    ViashDockerPullElseBuild $VSHD_ID
  elif [ "$VSHD_STRAT" == "alwayscachedbuild" -o "$VSHD_STRAT" == "cachedbuild" -o "$VSHD_STRAT" == "cb" ]; then
    ViashDockerBuild $VSHD_ID
  elif [[ "$VSHD_STRAT" =~ ^ifneedbe ]]; then
    set +e
    ViashDockerLocalTagCheck $VSHD_ID
    outCheck=$?
    set -e
    if [ $outCheck -eq 0 ]; then
      ViashInfo "Image $VSHD_ID already exists"
    elif [ "$VSHD_STRAT" == "ifneedbebuild" ]; then
      ViashDockerBuild $VSHD_ID --no-cache
    elif [ "$VSHD_STRAT" == "ifneedbecachedbuild" ]; then
      ViashDockerBuild $VSHD_ID
    elif [ "$VSHD_STRAT" == "ifneedbepull" ]; then
      ViashDockerPull $VSHD_ID
    elif [ "$VSHD_STRAT" == "ifneedbepullelsebuild" ]; then
      ViashDockerPullElseBuild $VSHD_ID --no-cache
    elif [ "$VSHD_STRAT" == "ifneedbepullelsecachedbuild" ]; then
      ViashDockerPullElseBuild $VSHD_ID
    else
      ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
      exit 1
    fi
  elif [ "$VSHD_STRAT" == "push" -o "$VSHD_STRAT" == "forcepush" -o "$VSHD_STRAT" == "alwayspush" ]; then
    set +e
    docker push $VSHD_ID
    outPush=$?
    set -e
    if [ $outPush -eq 0 ]; then
      ViashNotice "Container '$VSHD_ID' push succeeded."
    else
      ViashError "Container '$VSHD_ID' push errored."
      exit 1
    fi
  elif [ "$VSHD_STRAT" == "pushifnotpresent" -o "$VSHD_STRAT" == "gentlepush" -o "$VSHD_STRAT" == "maybepush" ]; then
    set +e
    ViashDockerRemoteTagCheck $VSHD_ID
    outCheck=$?
    set -e
    if [ $outCheck -eq 0 ]; then
      ViashNotice "Container '$VSHD_ID' exists, doing nothing."
    else
      ViashNotice "Container '$VSHD_ID' does not yet exist."
      set +e
      docker push $1 > /dev/null 2> /dev/null
      outPush=$?
      set -e
      if [ $outPush -eq 0 ]; then
        ViashNotice "Container '$VSHD_ID' push succeeded."
      else
      ViashError "Container '$VSHD_ID' push errored."
        exit 1
      fi
    fi
  elif [ "$VSHD_STRAT" == "donothing" -o "$VSHD_STRAT" == "meh" ]; then
    ViashNotice "Skipping setup."
  else
    ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
    exit 1
  fi
}


######## End of helper functions for setting up Docker images for viash ########

# ViashDockerFile: print the dockerfile to stdout
# return : dockerfile required to run this component
# examples:
#   ViashDockerFile
function ViashDockerfile {
  cat << 'VIASHDOCKER'
FROM dataintuitive/randpy:r4.0_py3.8_bioc3.12

RUN Rscript -e 'if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")' && \
  Rscript -e 'remotes::install_cran(c("dynwrap"), repos = "https://cran.rstudio.com")' && \
  Rscript -e 'remotes::install_github(c("dynverse/dyngen@devel"), repos = "https://cran.rstudio.com")'

VIASHDOCKER
}

# ViashDockerBuild: build a docker container
# $1              : image identifier with format `[registry/]image[:tag]`
# exit code $?    : whether or not the image was built
function ViashDockerBuild {

  # create temporary directory to store dockerfile & optional resources in
  tmpdir=$(mktemp -d "$VIASH_TEMP/viashsetupdocker-simulate_dyngen_dataset-XXXXXX")
  function clean_up {
    rm -rf "$tmpdir"
  }
  trap clean_up EXIT

  # store dockerfile and resources
  ViashDockerfile > $tmpdir/Dockerfile
  cp -r $VIASH_RESOURCES_DIR/* $tmpdir

  # Build the container
  ViashNotice "Running 'docker build -t $@ $tmpdir'"
  set +e
  if [ $VIASH_VERBOSITY -ge 6 ]; then
    docker build -t $@ $tmpdir
  else
    docker build -t $@ $tmpdir &> $tmpdir/docker_build.log
  fi
  out=$?
  set -e
  if [ ! $out -eq 0 ]; then
    ViashError "Error occurred while building the container $@."
    if [ ! $VIASH_VERBOSITY -ge 6 ]; then
      ViashError "Transcript: --------------------------------"
      cat "$tmpdir/docker_build.log"
      ViashError "End of transcript --------------------------"
    fi
    exit 1
  fi
}
# ViashAbsolutePath: generate absolute path from relative path
# borrowed from https://stackoverflow.com/a/21951256
# $1     : relative filename
# return : absolute path
# examples:
#   ViashAbsolutePath some_file.txt   # returns /path/to/some_file.txt
#   ViashAbsolutePath /foo/bar/..     # returns /foo
function ViashAbsolutePath {
  local thePath
  if [[ ! "$1" =~ ^/ ]]; then
    thePath="$PWD/$1"
  else
    thePath="$1"
  fi
  echo "$thePath" | (
    IFS=/
    read -a parr
    declare -a outp
    for i in "${parr[@]}"; do
      case "$i" in
      ''|.) continue ;;
      ..)
        len=${#outp[@]}
        if ((len==0)); then
          continue
        else
          unset outp[$((len-1))]
        fi
        ;;
      *)
        len=${#outp[@]}
        outp[$len]="$i"
      ;;
      esac
    done
    echo /"${outp[*]}"
  )
}
# ViashAutodetectMount: auto configuring docker mounts from parameters
# $1                  : The parameter value
# returns             : New parameter
# $VIASH_EXTRA_MOUNTS : Added another parameter to be passed to docker
# examples:
#   ViashAutodetectMount /path/to/bar      # returns '/viash_automount/path/to/bar'
#   ViashAutodetectMountArg /path/to/bar   # returns '-v /path/to:/viash_automount/path/to'
function ViashAutodetectMount {
  abs_path=$(ViashAbsolutePath "$1")
  if [ -d "$abs_path" ]; then
    mount_source="$abs_path"
    base_name=""
  else
    mount_source=`dirname "$abs_path"`
    base_name=`basename "$abs_path"`
  fi
  mount_target="/viash_automount$mount_source"
  echo "$mount_target/$base_name"
}
function ViashAutodetectMountArg {
  abs_path=$(ViashAbsolutePath "$1")
  if [ -d "$abs_path" ]; then
    mount_source="$abs_path"
    base_name=""
  else
    mount_source=`dirname "$abs_path"`
    base_name=`basename "$abs_path"`
  fi
  mount_target="/viash_automount$mount_source"
  echo "-v \"$mount_source:$mount_target\""
}
# ViashExtractFlags: Retain leading flag
# $1     : string with a possible leading flag
# return : leading flag
# examples:
#   ViashExtractFlags --foo=bar  # returns --foo
function ViashExtractFlags {
  echo $1 | sed 's/=.*//'
}
# initialise variables
VIASH_EXTRA_MOUNTS=''

# initialise array
VIASH_POSITIONAL_ARGS=''

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            ViashHelp
            exit
            ;;
        -v|--verbose)
            let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
            shift 1
            ;;
        -vv)
            let "VIASH_VERBOSITY=VIASH_VERBOSITY+2"
            shift 1
            ;;
        --verbosity)
            VIASH_VERBOSITY="$2"
            shift 2
            ;;
        --verbosity=*)
            VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
            shift 1
            ;;
        --version)
            echo "simulate_dyngen_dataset 1.1.0"
            exit
            ;;
        --id)
            VIASH_PAR_ID="$2"
            shift 2
            ;;
        --id=*)
            VIASH_PAR_ID=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --reference_rna)
            VIASH_PAR_REFERENCE_RNA="$2"
            shift 2
            ;;
        --reference_rna=*)
            VIASH_PAR_REFERENCE_RNA=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --reference_mod2)
            VIASH_PAR_REFERENCE_MOD2="$2"
            shift 2
            ;;
        --reference_mod2=*)
            VIASH_PAR_REFERENCE_MOD2=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --output_rna)
            VIASH_PAR_OUTPUT_RNA="$2"
            shift 2
            ;;
        --output_rna=*)
            VIASH_PAR_OUTPUT_RNA=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --output_mod2)
            VIASH_PAR_OUTPUT_MOD2="$2"
            shift 2
            ;;
        --output_mod2=*)
            VIASH_PAR_OUTPUT_MOD2=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --plot)
            VIASH_PAR_PLOT="$2"
            shift 2
            ;;
        --plot=*)
            VIASH_PAR_PLOT=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        -p)
            VIASH_PAR_PLOT="$2"
            shift 2
            ;;
        --num_cells)
            VIASH_PAR_NUM_CELLS="$2"
            shift 2
            ;;
        --num_cells=*)
            VIASH_PAR_NUM_CELLS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --num_genes)
            VIASH_PAR_NUM_GENES="$2"
            shift 2
            ;;
        --num_genes=*)
            VIASH_PAR_NUM_GENES=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --num_simulations)
            VIASH_PAR_NUM_SIMULATIONS="$2"
            shift 2
            ;;
        --num_simulations=*)
            VIASH_PAR_NUM_SIMULATIONS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --census_interval)
            VIASH_PAR_CENSUS_INTERVAL="$2"
            shift 2
            ;;
        --census_interval=*)
            VIASH_PAR_CENSUS_INTERVAL=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --ssa_tau)
            VIASH_PAR_SSA_TAU="$2"
            shift 2
            ;;
        --ssa_tau=*)
            VIASH_PAR_SSA_TAU=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --store_chromatin)
            VIASH_PAR_STORE_CHROMATIN=true
            shift 1
            ;;
        -chromatin)
            VIASH_PAR_STORE_CHROMATIN=true
            shift 1
            ;;
        --store_protein)
            VIASH_PAR_STORE_PROTEIN=true
            shift 1
            ;;
        -protein)
            VIASH_PAR_STORE_PROTEIN=true
            shift 1
            ;;
        --num_threads)
            VIASH_PAR_NUM_THREADS="$2"
            shift 2
            ;;
        --num_threads=*)
            VIASH_PAR_NUM_THREADS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --seed)
            VIASH_PAR_SEED="$2"
            shift 2
            ;;
        --seed=*)
            VIASH_PAR_SEED=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --cache_dir)
            VIASH_PAR_CACHE_DIR="$2"
            shift 2
            ;;
        --cache_dir=*)
            VIASH_PAR_CACHE_DIR=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        ---setup)
            ViashDockerSetup 'openproblems/common_datasets_simulate_dyngen_dataset:1.1.0' "$2"
            exit 0
            ;;
        ---setup=*)
            ViashDockerSetup 'openproblems/common_datasets_simulate_dyngen_dataset:1.1.0' "$(ViashRemoveFlags "$1")"
            exit 0
            ;;
        ---dockerfile)
            ViashDockerfile
            exit 0
            ;;
        ---v|---volume)
            VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS -v "$2""
            shift 2
            ;;
        ---volume=*)
            VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS -v $(ViashRemoveFlags "$2")"
            shift 1
            ;;
        ---debug)
            ViashNotice "+ docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t openproblems/common_datasets_simulate_dyngen_dataset:1.1.0"
            docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t openproblems/common_datasets_simulate_dyngen_dataset:1.1.0
            exit 0
            ;;
        *)  # positional arg or unknown option
            # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
            VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
            shift # past argument
            ;;
    esac
done

# parse positional parameters
eval set -- $VIASH_POSITIONAL_ARGS



# check whether required parameters exist
if [ -z "$VIASH_PAR_ID" ]; then
  ViashError '--id' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_OUTPUT_RNA" ]; then
  ViashError '--output_rna' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_OUTPUT_MOD2" ]; then
  ViashError '--output_mod2' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_PLOT" ]; then
  ViashError '--plot' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_NUM_CELLS" ]; then
  VIASH_PAR_NUM_CELLS="100"
fi
if [ -z "$VIASH_PAR_NUM_GENES" ]; then
  VIASH_PAR_NUM_GENES="100"
fi
if [ -z "$VIASH_PAR_NUM_SIMULATIONS" ]; then
  VIASH_PAR_NUM_SIMULATIONS="32"
fi
if [ -z "$VIASH_PAR_CENSUS_INTERVAL" ]; then
  VIASH_PAR_CENSUS_INTERVAL="4.0"
fi
if [ -z "$VIASH_PAR_SSA_TAU" ]; then
  VIASH_PAR_SSA_TAU="0.008333"
fi
if [ -z "$VIASH_PAR_STORE_CHROMATIN" ]; then
  VIASH_PAR_STORE_CHROMATIN="false"
fi
if [ -z "$VIASH_PAR_STORE_PROTEIN" ]; then
  VIASH_PAR_STORE_PROTEIN="false"
fi
if [ -z "$VIASH_PAR_NUM_THREADS" ]; then
  VIASH_PAR_NUM_THREADS="1"
fi

ViashDockerSetup 'openproblems/common_datasets_simulate_dyngen_dataset:1.1.0' ifneedbepullelsecachedbuild

# detect volumes from file arguments
if [ ! -z "$VIASH_PAR_REFERENCE_RNA" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_REFERENCE_RNA")"
  VIASH_PAR_REFERENCE_RNA=$(ViashAutodetectMount "$VIASH_PAR_REFERENCE_RNA")
fi
if [ ! -z "$VIASH_PAR_REFERENCE_MOD2" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_REFERENCE_MOD2")"
  VIASH_PAR_REFERENCE_MOD2=$(ViashAutodetectMount "$VIASH_PAR_REFERENCE_MOD2")
fi
if [ ! -z "$VIASH_PAR_OUTPUT_RNA" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_OUTPUT_RNA")"
  VIASH_PAR_OUTPUT_RNA=$(ViashAutodetectMount "$VIASH_PAR_OUTPUT_RNA")
fi
if [ ! -z "$VIASH_PAR_OUTPUT_MOD2" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_OUTPUT_MOD2")"
  VIASH_PAR_OUTPUT_MOD2=$(ViashAutodetectMount "$VIASH_PAR_OUTPUT_MOD2")
fi
if [ ! -z "$VIASH_PAR_PLOT" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_PLOT")"
  VIASH_PAR_PLOT=$(ViashAutodetectMount "$VIASH_PAR_PLOT")
fi
if [ ! -z "$VIASH_PAR_CACHE_DIR" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_CACHE_DIR")"
  VIASH_PAR_CACHE_DIR=$(ViashAutodetectMount "$VIASH_PAR_CACHE_DIR")
fi

# Always mount the resource directory
VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_RESOURCES_DIR")"
VIASH_RESOURCES_DIR=$(ViashAutodetectMount "$VIASH_RESOURCES_DIR")

# Always mount the VIASH_TEMP directory
VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_TEMP")"
VIASH_TEMP=$(ViashAutodetectMount "$VIASH_TEMP")

# change file ownership
function viash_perform_chown {
  
  if [ ! -z "$VIASH_PAR_OUTPUT_RNA" ]; then
    eval docker run --entrypoint=chown -i --rm $VIASH_EXTRA_MOUNTS openproblems/common_datasets_simulate_dyngen_dataset:1.1.0 "$(id -u):$(id -g)" --silent --recursive "$VIASH_PAR_OUTPUT_RNA"
  fi
  if [ ! -z "$VIASH_PAR_OUTPUT_MOD2" ]; then
    eval docker run --entrypoint=chown -i --rm $VIASH_EXTRA_MOUNTS openproblems/common_datasets_simulate_dyngen_dataset:1.1.0 "$(id -u):$(id -g)" --silent --recursive "$VIASH_PAR_OUTPUT_MOD2"
  fi
  if [ ! -z "$VIASH_PAR_PLOT" ]; then
    eval docker run --entrypoint=chown -i --rm $VIASH_EXTRA_MOUNTS openproblems/common_datasets_simulate_dyngen_dataset:1.1.0 "$(id -u):$(id -g)" --silent --recursive "$VIASH_PAR_PLOT"
  fi
}
trap viash_perform_chown EXIT


cat << VIASHEOF | eval docker run --entrypoint=bash -i --rm $VIASH_EXTRA_MOUNTS openproblems/common_datasets_simulate_dyngen_dataset:1.1.0
set -e
tempscript=\$(mktemp "$VIASH_TEMP/viash-run-simulate_dyngen_dataset-XXXXXX")
function clean_up {
  rm "\$tempscript"
}
trap clean_up EXIT
cat > "\$tempscript" << 'VIASHMAIN'
cat("Loading dependencies\\n")
options(tidyverse.quiet = TRUE)
library(tidyverse)
library(dyngen, quietly = TRUE, warn.conflicts = FALSE)
library(Matrix, quietly = TRUE, warn.conflicts = FALSE)
requireNamespace("anndata", quietly = TRUE)

## VIASH START
# The following code has been auto-generated by Viash.
par <- list(
  "id" = $( if [ ! -z ${VIASH_PAR_ID+x} ]; then echo "'$VIASH_PAR_ID'"; else echo NULL; fi ),
  "reference_rna" = $( if [ ! -z ${VIASH_PAR_REFERENCE_RNA+x} ]; then echo "'$VIASH_PAR_REFERENCE_RNA'"; else echo NULL; fi ),
  "reference_mod2" = $( if [ ! -z ${VIASH_PAR_REFERENCE_MOD2+x} ]; then echo "'$VIASH_PAR_REFERENCE_MOD2'"; else echo NULL; fi ),
  "output_rna" = $( if [ ! -z ${VIASH_PAR_OUTPUT_RNA+x} ]; then echo "'$VIASH_PAR_OUTPUT_RNA'"; else echo NULL; fi ),
  "output_mod2" = $( if [ ! -z ${VIASH_PAR_OUTPUT_MOD2+x} ]; then echo "'$VIASH_PAR_OUTPUT_MOD2'"; else echo NULL; fi ),
  "plot" = $( if [ ! -z ${VIASH_PAR_PLOT+x} ]; then echo "'$VIASH_PAR_PLOT'"; else echo NULL; fi ),
  "num_cells" = $( if [ ! -z ${VIASH_PAR_NUM_CELLS+x} ]; then echo "as.integer($VIASH_PAR_NUM_CELLS)"; else echo NULL; fi ),
  "num_genes" = $( if [ ! -z ${VIASH_PAR_NUM_GENES+x} ]; then echo "as.integer($VIASH_PAR_NUM_GENES)"; else echo NULL; fi ),
  "num_simulations" = $( if [ ! -z ${VIASH_PAR_NUM_SIMULATIONS+x} ]; then echo "as.integer($VIASH_PAR_NUM_SIMULATIONS)"; else echo NULL; fi ),
  "census_interval" = $( if [ ! -z ${VIASH_PAR_CENSUS_INTERVAL+x} ]; then echo "as.numeric($VIASH_PAR_CENSUS_INTERVAL)"; else echo NULL; fi ),
  "ssa_tau" = $( if [ ! -z ${VIASH_PAR_SSA_TAU+x} ]; then echo "as.numeric($VIASH_PAR_SSA_TAU)"; else echo NULL; fi ),
  "store_chromatin" = $( if [ ! -z ${VIASH_PAR_STORE_CHROMATIN+x} ]; then echo "as.logical(toupper('$VIASH_PAR_STORE_CHROMATIN'))"; else echo NULL; fi ),
  "store_protein" = $( if [ ! -z ${VIASH_PAR_STORE_PROTEIN+x} ]; then echo "as.logical(toupper('$VIASH_PAR_STORE_PROTEIN'))"; else echo NULL; fi ),
  "num_threads" = $( if [ ! -z ${VIASH_PAR_NUM_THREADS+x} ]; then echo "as.integer($VIASH_PAR_NUM_THREADS)"; else echo NULL; fi ),
  "seed" = $( if [ ! -z ${VIASH_PAR_SEED+x} ]; then echo "as.integer($VIASH_PAR_SEED)"; else echo NULL; fi ),
  "cache_dir" = $( if [ ! -z ${VIASH_PAR_CACHE_DIR+x} ]; then echo "'$VIASH_PAR_CACHE_DIR'"; else echo NULL; fi )
)

resources_dir = "$VIASH_RESOURCES_DIR"

## VIASH END

if (!is.null(par\$seed)) {
  set.seed(par\$seed)
}
if (par\$store_protein == par\$store_chromatin) {
  stop("Warning: Strictly pass one of --store_protein and --store_chromatin, not neither or both.\\n")
}

# Read reference datasets
ref_rna <-
  if (!is.null(par\$reference_rna)) {
    anndata::read_h5ad(par\$reference_rna)
  } else {
    NULL
  }
ref_mod2 <-
  if (!is.null(par\$reference_mod2)) {
    ad <- anndata::read_h5ad(par\$reference_mod2)
    if (par\$store_protein && unique(ad\$var[["feature_types"]]) != "ADT") {
      stop("If --store_protein, reference_mod2 should be an ADT dataset")
    }
    if (par\$store_chromatin && unique(ad\$var[["feature_types"]]) != "ATAC") {
      stop("If --store_chromatin, reference_mod2 should be an ATAC dataset")
    }
    ad
  } else {
    NULL
  }

# start from linear
backbone_init <- bblego(
  bblego_start("A", type = "simple"),
  bblego_linear("A", "B", num_modules = 10),
  bblego_linear("B", "C", num_modules = 10),
  bblego_linear("C", "D", num_modules = 10),
  bblego_end("D")
)

# add a simple cycle to it
module_info <- bind_rows(
  backbone_init\$module_info %>% select(-color),
  tribble(
    ~module_id, ~basal, ~burn, ~independence,
    "CC1", 0, TRUE, 1,
    "CC2", 1, TRUE, 1,
    "CC3", 0, TRUE, 1,
    "CC4", 1, TRUE, 1,
    "CC5", 0, TRUE, 1
  )
)
module_network <- bind_rows(
  backbone_init\$module_network,
  tribble(
    ~from, ~to, ~effect, ~strength, ~hill,
    "Burn1", "CC1", 1L, 1, 2,
    "CC1", "CC2", -1L, 100, 2,
    "CC2", "CC3", 1L, 1, 2,
    "CC3", "CC4", -1L, 100, 2,
    "CC4", "CC5", 1L, 1, 2,
    "CC5", "CC1", -1L, 100, 2
  )
)
backbone <- backbone(
  module_info = module_info,
  module_network = module_network,
  expression_patterns = backbone_init\$expression_patterns
)

# compute simulation times
burn_time <- simtime_from_backbone(backbone, burn = TRUE) * 4
total_time <- simtime_from_backbone(backbone, burn = FALSE) / 3

cat("Generating regulatory network\\n")
num_tfs <- nrow(backbone\$module_info)
num_targets <- ceiling(0.8 * (par\$num_genes - num_tfs))
num_hks <- par\$num_genes - num_tfs - num_targets
num_cells_train <- round(par\$num_cells * .66)
num_cells_test <- par\$num_cells - num_cells_train

model_init <- initialise_model(
  backbone = backbone,
  num_cells = num_cells_train,
  num_tfs = num_tfs,
  num_targets = num_targets,
  num_hks = num_hks,
  simulation_params = simulation_default(
    burn_time = burn_time,
    total_time = total_time,
    census_interval = par\$census_interval,
    ssa_algorithm = ssa_etl(tau = par\$ssa_tau),
    experiment_params = simulation_type_wild_type(
      num_simulations = round(0.66*par\$num_simulations)
    ),
    compute_cellwise_grn = par\$store_chromatin
  ),
  experiment_params = experiment_snapshot(
    realcount = if (!is.null(ref_rna)) ref_rna\$X else NULL,
  ),
  num_cores = par\$num_threads,
  verbose = TRUE,
  download_cache_dir = par\$cache_dir
) %>%
  generate_tf_network() %>%
  generate_feature_network()

cat("Running simulations for training cells\\n")
model_train <-
  model_init %>%
  generate_kinetics() %>%
  generate_gold_standard() %>%
  generate_cells() %>%
  generate_experiment()

cat("Running simulations for test cells\\n")
model_init\$num_cells <-
  model_init\$numbers\$num_cells <-
  num_cells_test
model_init\$simulation_params\$experiment_params <-
  simulation_type_wild_type(round(0.37*par\$num_simulations))
model_test <-
  model_init %>%
  generate_kinetics() %>% # use different kinetics
  generate_gold_standard() %>%
  generate_cells() %>%
  generate_experiment()

cat("Combine simulations into one dataset\\n")
model <- combine_models(
  list(
    batch1 = model_train,
    batch2 = model_test
  ),
  duplicate_gold_standard = FALSE
)
dataset <- as_dyno(model)

# check whether output dataset looks nice
# and whether batch effect is present
# plot_summary(model)


cat("Compute cell cycle scores\\n")
phase_scores <- map_df(unique(dataset\$cell_info\$model), function(mod) {
  ix <- dataset\$cell_info\$model == mod
  cp <- dataset\$counts_protein[ix, ]
  expr1 <- dynutils::scale_quantile(cp[, "CC2_TF1"])
  expr2 <- dynutils::scale_quantile(cp[, "CC5_TF1"])
  tibble(
    cell_id = rownames(cp),
    S_score = (expr1 - expr2) / 2 + .5,
    G2M_score = (expr2 - expr1) / 2 + .5
  )
})

# ggplot(phase_scores) + geom_point(aes(S_score, G2M_score))
cat("Process trajectory pseudotimes\\n")
pseudotime <- dataset %>%
  dynwrap::add_root(root_milestone_id = "sA") %>%
  dynwrap::calculate_pseudotime() %>%
  enframe("cell_id", "pseudotime_order_GEX")

if (par\$store_protein) {
  pseudotime\$pseudotime_order_ADT <- pseudotime\$pseudotime_order_GEX
}
if (par\$store_chromatin) {
  pseudotime\$pseudotime_order_ATAC <- pseudotime\$pseudotime_order_GEX
}

cat("Create RNA dataset\\n")
celltypes <- dataset\$milestone_percentages %>%
  group_by(cell_id) %>%
  slice(which.max(percentage)) %>%
  ungroup() %>%
  select(cell_id, cell_type = milestone_id)
obs <- dataset\$cell_info %>%
  left_join(celltypes, by = "cell_id") %>%
  left_join(phase_scores, by = "cell_id") %>%
  left_join(pseudotime, by = "cell_id") %>%
  rename(batch = model) %>%
  column_to_rownames("cell_id")

# ggplot(obs) + geom_point(aes(pseudotime, G2M_score, colour = batch))
var <- dataset\$feature_info %>%
  select(feature_id, module_id, basal, burn, independence, color, is_tf, is_hk) %>%
  column_to_rownames("feature_id")
ad_mod1 <- anndata::AnnData(
  X = dataset\$counts,
  obs = obs,
  var = var %>% mutate(feature_types = "GEX"),
  uns = list(
    dataset_id = par\$id,
      organism = "synthetic"
  )
)

if (par\$store_protein) {
  cat("Processing Antibody data\\n")
  # construct AbSeq-like data from protein counts
  counts_protein_sim <- dataset\$counts_protein
  var_protein <- var %>% mutate(feature_types = "ADT")

  # map counts using reference dataset
  counts_protein <-
    if (!is.null(ref_mod2)) {
      dyngen:::.simulate_counts_from_realcounts(counts_protein_sim, ref_mod2\$X)
    } else {
      counts_protein_sim
    }

  # sample 50 genes
  if (!is.null(ref_mod2) && ncol(counts_protein) > ncol(ref_mod2)) {
    sample_genes <- sample.int(ncol(counts_protein), ncol(ref_mod2))
    counts_protein <- counts_protein[, sample_genes, , drop = FALSE]
    var_protein <- var_protein[sample_genes, , drop = FALSE]
  }

  ad_mod2 <- anndata::AnnData(
    X = counts_protein,
    obs = obs,
    var = var_protein,
    uns = list(
      dataset_id = par\$id,
      organism = "synthetic"
    )
  )
}

if (par\$store_chromatin) {
  cat("Processing ATAC data\\n")
  # constuct atac-like data from single cell regulatory network
  # TODO: use real atac data to map distributions
  mat <- dataset\$regulatory_network_sc %>%
    mutate(
      edge = factor(paste0(as.character(regulator), "->", as.character(target)))
    )
  regsc <- Matrix::sparseMatrix(
    i = as.integer(mat\$cell_id),
    j = as.integer(mat\$edge),
    x = pmax(mat\$strength, 0) * 100
  )
  rownames(regsc) <- dataset\$cell_ids
  colnames(regsc) <- paste0("region_", seq_len(ncol(regsc)))
  var_atac <- data.frame(
    row.names = colnames(regsc),
    feature_types = rep("ATAC", ncol(regsc))
  )

  # map counts using reference dataset
  counts_atac <-
    if (!is.null(ref_mod2)) {
      dyngen:::.simulate_counts_from_realcounts(regsc, ref_mod2\$X)
    } else {
      regsc
    }

  ad_mod2 <- anndata::AnnData(
    X = counts_atac,
    obs = obs,
    var = var_atac,
    uns = list(
      dataset_id = par\$id,
      organism = "synthetic"
    )
  )
}

cat("Write h5ad files\\n")
print(ad_mod1)
ad_mod1\$write_h5ad(par\$output_rna, compression = "gzip")
print(ad_mod2)
ad_mod2\$write_h5ad(par\$output_mod2, compression = "gzip")

if (!is.null(par\$plot)) {
  cat("Storing summary plot\\n")
  g <- plot_summary(model)
  ggsave(par\$plot, g, width = 20, height = 16)
}
VIASHMAIN
PATH="$VIASH_RESOURCES_DIR:\$PATH"

Rscript "\$tempscript"

VIASHEOF
