functionality:
  name: "simulate_dyngen_dataset"
  namespace: "common_datasets"
  version: "main_build"
  authors:
  - name: "Robrecht Cannoodt"
    email: "rcannood@gmail.com"
    roles:
    - "author"
    - "maintainer"
    props:
      github: "rcannood"
      orcid: "0000-0003-3641-729X"
  arguments:
  - type: "string"
    name: "--id"
    alternatives: []
    description: "The id of the output dataset id"
    example: "dyngen_dataset"
    required: true
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "file"
    name: "--output_rna"
    alternatives: []
    description: "Output h5ad RNA file."
    example: "output_rna.h5ad"
    must_exist: false
    required: true
    direction: "Output"
    multiple: false
    multiple_sep: ":"
  - type: "file"
    name: "--output_mod2"
    alternatives: []
    description: "Output h5ad modality2 file (ATAC or Antibody capture)."
    example: "output_mod2.h5ad"
    must_exist: false
    required: true
    direction: "Output"
    multiple: false
    multiple_sep: ":"
  - type: "file"
    name: "--plot"
    alternatives:
    - "-p"
    description: "A visualisation of the simulation."
    example: "plot.pdf"
    must_exist: false
    required: true
    direction: "Output"
    multiple: false
    multiple_sep: ":"
  - type: "string"
    name: "--backbone"
    alternatives:
    - "-b"
    description: "Which dyngen backbone to use for the simulation."
    default: "bifurcating"
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--num_cells"
    alternatives: []
    description: "The number of cells to generate."
    default: 100
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--num_genes"
    alternatives: []
    description: "The number of genes to generate."
    default: 100
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--num_simulations"
    alternatives: []
    description: "The number of dyngen simulations to run."
    default: 32
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--census_interval"
    alternatives: []
    description: "A granularity parameter for the outputted simulation."
    default: 4.0
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--ssa_tau"
    alternatives: []
    description: "Step size of the GillespieSSA2 simulation. Default is 30/3600."
    default: 0.008333
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "boolean_true"
    name: "--store_chromatin"
    alternatives:
    - "-chromatin"
    description: "Whether or not to compute chromatin accessibility data."
    direction: "Input"
  - type: "boolean_true"
    name: "--store_protein"
    alternatives:
    - "-protein"
    description: "Whether or not to store protein count information."
    direction: "Input"
  - type: "integer"
    name: "--num_proteins"
    alternatives: []
    description: "The number of proteins to sample."
    default: 50
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--num_threads"
    alternatives: []
    description: "Parallellisation level."
    default: 1
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "file"
    name: "--cache_dir"
    alternatives: []
    description: "A caching directory for files that dyngen downloads."
    must_exist: false
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  resources:
  - type: "bash_script"
    text: |
      #!/usr/bin/env bash
      
      ############################################
      #    simulate_dyngen_dataset main_build    #
      ############################################
      
      # This wrapper script is auto-generated by viash 0.5.1 and is thus a derivative
      # work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
      # Intuitive.  The component may contain files which fall under a different
      # license. The authors of this component should specify the license in the
      # header of such files, or include a separate license file detailing the
      # licenses of all included files.
      #
      # Component authors:
      # * Robrecht Cannoodt <rcannood@gmail.com> (author, maintainer) {github: rcannood, orcid: 0000-0003-3641-729X}
      
      set -e
      
      if [ -z "$VIASH_TEMP" ]; then
        VIASH_TEMP=/tmp
      fi
      
      # define helper functions
      # ViashQuote: put quotes around non flag values
      # $1     : unquoted string
      # return : possibly quoted string
      # examples:
      #   ViashQuote --foo      # returns --foo
      #   ViashQuote bar        # returns 'bar'
      #   Viashquote --foo=bar  # returns --foo='bar'
      function ViashQuote {
        if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
          echo "$1" | sed "s#=\(.*\)#='\1'#"
        elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
          echo "$1"
        else
          echo "'$1'"
        fi
      }
      # ViashRemoveFlags: Remove leading flag
      # $1     : string with a possible leading flag
      # return : string without possible leading flag
      # examples:
      #   ViashRemoveFlags --foo=bar  # returns bar
      function ViashRemoveFlags {
        echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
      }
      # ViashSourceDir: return the path of a bash file, following symlinks
      # usage   : ViashSourceDir ${BASH_SOURCE[0]}
      # $1      : Should always be set to ${BASH_SOURCE[0]}
      # returns : The absolute path of the bash file
      function ViashSourceDir {
        SOURCE="$1"
        while [ -h "$SOURCE" ]; do
          DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
          SOURCE="$(readlink "$SOURCE")"
          [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
        done
        cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
      }
      VIASH_VERBOSITY=5
      
      # see https://en.wikipedia.org/wiki/Syslog#Severity_level
      
      # ViashLog: Log events depending on the verbosity level
      # usage: ViashLog 1 alert Oh no something went wrong!
      # $1: required verbosity level
      # $2: display tag
      # $3+: messages to display
      # stdout: Your input, prepended by '[$2] '. 
      function ViashLog {
        local required_level="$1"
        local display_tag="$2"
        shift 2
        if [ $VIASH_VERBOSITY -ge $required_level ]; then
          echo "[$display_tag]" "$@"
        fi
      }
      
      # ViashEmergency: log events when the system is unstable
      # usage: ViashEmergency Oh no something went wrong.
      # stdout: Your input, prepended by '[emergency] '. 
      function ViashEmergency {
        ViashLog 0 emergency $@
      }
      
      # ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
      # usage: ViashAlert Oh no something went wrong.
      # stdout: Your input, prepended by '[alert] '. 
      function ViashAlert {
        ViashLog 1 alert $@
      }
      
      # ViashCritical: log events when a critical condition occurs
      # usage: ViashCritical Oh no something went wrong.
      # stdout: Your input, prepended by '[critical] '. 
      function ViashCritical {
        ViashLog 2 critical $@
      }
      
      # ViashError: log events when an error condition occurs
      # usage: ViashError Oh no something went wrong.
      # stdout: Your input, prepended by '[error] '. 
      function ViashError {
        ViashLog 3 error $@
      }
      
      # ViashWarning: log potentially abnormal events
      # usage: ViashWarning Something may have gone wrong.
      # stdout: Your input, prepended by '[warning] '. 
      function ViashWarning {
        ViashLog 4 warning $@
      }
      
      # ViashNotice: log significant but normal events
      # usage: ViashNotice This just happened.
      # stdout: Your input, prepended by '[notice] '. 
      function ViashNotice {
        ViashLog 5 notice $@
      }
      
      # ViashInfo: log normal events
      # usage: ViashInfo This just happened.
      # stdout: Your input, prepended by '[info] '. 
      function ViashInfo {
        ViashLog 6 info $@
      }
      
      # ViashDebug: log all events, for debugging purposes
      # usage: ViashDebug This just happened.
      # stdout: Your input, prepended by '[debug] '. 
      function ViashDebug {
        ViashLog 7 debug $@
      }
      
      # find source folder of this component
      VIASH_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`
      
      
      # ViashHelp: Display helpful explanation about this executable
      function ViashHelp {
        echo "simulate_dyngen_dataset main_build"
        echo "Generate a synthetic dataset using the standard dyngen simulation workflow."
        echo "For more advanced usage to get more control over the outputted dataset, use the"
        echo "R package. More documentation can be found at https://dyngen.dynverse.org."
        echo
        echo "Options:"
      
        echo "   --id"
        echo "        type: string, required parameter"
        echo "        example: dyngen_dataset"
        echo "        The id of the output dataset id"
        echo ""
      
      
        echo "   --output_rna"
        echo "        type: file, required parameter, output"
        echo "        example: output_rna.h5ad"
        echo "        Output h5ad RNA file."
        echo ""
      
      
        echo "   --output_mod2"
        echo "        type: file, required parameter, output"
        echo "        example: output_mod2.h5ad"
        echo "        Output h5ad modality2 file (ATAC or Antibody capture)."
        echo ""
      
      
        echo "   -p, --plot"
        echo "        type: file, required parameter, output"
        echo "        example: plot.pdf"
        echo "        A visualisation of the simulation."
        echo ""
      
      
        echo "   -b, --backbone"
        echo "        type: string"
        echo "        default: bifurcating"
        echo "        Which dyngen backbone to use for the simulation."
        echo ""
      
      
        echo "   --num_cells"
        echo "        type: integer"
        echo "        default: 100"
        echo "        The number of cells to generate."
        echo ""
      
      
        echo "   --num_genes"
        echo "        type: integer"
        echo "        default: 100"
        echo "        The number of genes to generate."
        echo ""
      
      
        echo "   --num_simulations"
        echo "        type: integer"
        echo "        default: 32"
        echo "        The number of dyngen simulations to run."
        echo ""
      
      
        echo "   --census_interval"
        echo "        type: double"
        echo "        default: 4.0"
        echo "        A granularity parameter for the outputted simulation."
        echo ""
      
      
        echo "   --ssa_tau"
        echo "        type: double"
        echo "        default: 0.008333"
        echo "        Step size of the GillespieSSA2 simulation. Default is 30/3600."
        echo ""
      
      
        echo "   -chromatin, --store_chromatin"
        echo "        type: boolean_true"
        echo "        Whether or not to compute chromatin accessibility data."
        echo ""
      
      
        echo "   -protein, --store_protein"
        echo "        type: boolean_true"
        echo "        Whether or not to store protein count information."
        echo ""
      
      
        echo "   --num_proteins"
        echo "        type: integer"
        echo "        default: 50"
        echo "        The number of proteins to sample."
        echo ""
      
      
        echo "   --num_threads"
        echo "        type: integer"
        echo "        default: 1"
        echo "        Parallellisation level."
        echo ""
      
      
        echo "   --cache_dir"
        echo "        type: file"
        echo "        A caching directory for files that dyngen downloads."
        echo ""
      
      }
      ######## Helper functions for setting up Docker images for viash ########
      
      
      # ViashDockerRemoteTagCheck: check whether a Docker image is available 
      # on a remote. Assumes `docker login` has been performed, if relevant.
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # exit code $?        : whether or not the image was found
      # examples:
      #   ViashDockerRemoteTagCheck python:latest
      #   echo $?                                     # returns '0'
      #   ViashDockerRemoteTagCheck sdaizudceahifu
      #   echo $?                                     # returns '1'
      function ViashDockerRemoteTagCheck {
        docker manifest inspect $1 > /dev/null 2> /dev/null
      }
      
      # ViashDockerLocalTagCheck: check whether a Docker image is available locally
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # exit code $?        : whether or not the image was found
      # examples:
      #   docker pull python:latest
      #   ViashDockerLocalTagCheck python:latest
      #   echo $?                                     # returns '0'
      #   ViashDockerLocalTagCheck sdaizudceahifu
      #   echo $?                                     # returns '1'
      function ViashDockerLocalTagCheck {
        [ -n "$(docker images -q $1)" ]
      }
      
      # ViashDockerPull: pull a Docker image
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # exit code $?        : whether or not the image was found
      # examples:
      #   ViashDockerPull python:latest
      #   echo $?                                     # returns '0'
      #   ViashDockerPull sdaizudceahifu
      #   echo $?                                     # returns '1'
      function ViashDockerPull {
        ViashNotice "Running 'docker pull $1'"
        docker pull $1 && return 0 || return 1
      }
      
      # ViashDockerPullElseBuild: pull a Docker image, else build it
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
      # examples:
      #   ViashDockerPullElseBuild mynewcomponent
      function ViashDockerPullElseBuild {
        set +e
        ViashDockerPull $1
        out=$?
        set -e
        if [ $out -ne 0 ]; then
          ViashDockerBuild $@
        fi
      }
      
      # ViashDockerSetup: create a Docker image, according to specified docker setup strategy
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # $2                  : docker setup strategy, see DockerSetupStrategy.scala
      # ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
      # examples:
      #   ViashDockerSetup mynewcomponent alwaysbuild
      function ViashDockerSetup {
        VSHD_ID="$1"
        VSHD_STRAT="$2"
        if [ "$VSHD_STRAT" == "alwaysbuild" -o "$VSHD_STRAT" == "build" -o "$VSHD_STRAT" == "b" ]; then
          ViashDockerBuild $VSHD_ID --no-cache
        elif [ "$VSHD_STRAT" == "alwayspull" -o "$VSHD_STRAT" == "pull" -o "$VSHD_STRAT" == "p" ]; then
          ViashDockerPull $VSHD_ID
        elif [ "$VSHD_STRAT" == "alwayspullelsebuild" -o "$VSHD_STRAT" == "pullelsebuild" ]; then
          ViashDockerPullElseBuild $VSHD_ID --no-cache
        elif [ "$VSHD_STRAT" == "alwayspullelsecachedbuild" -o "$VSHD_STRAT" == "pullelsecachedbuild" ]; then
          ViashDockerPullElseBuild $VSHD_ID
        elif [ "$VSHD_STRAT" == "alwayscachedbuild" -o "$VSHD_STRAT" == "cachedbuild" -o "$VSHD_STRAT" == "cb" ]; then
          ViashDockerBuild $VSHD_ID
        elif [[ "$VSHD_STRAT" =~ ^ifneedbe ]]; then
          set +e
          ViashDockerLocalTagCheck $VSHD_ID
          outCheck=$?
          set -e
          if [ $outCheck -eq 0 ]; then
            ViashInfo "Image $VSHD_ID already exists"
          elif [ "$VSHD_STRAT" == "ifneedbebuild" ]; then
            ViashDockerBuild $VSHD_ID --no-cache
          elif [ "$VSHD_STRAT" == "ifneedbecachedbuild" ]; then
            ViashDockerBuild $VSHD_ID
          elif [ "$VSHD_STRAT" == "ifneedbepull" ]; then
            ViashDockerPull $VSHD_ID
          elif [ "$VSHD_STRAT" == "ifneedbepullelsebuild" ]; then
            ViashDockerPullElseBuild $VSHD_ID --no-cache
          elif [ "$VSHD_STRAT" == "ifneedbepullelsecachedbuild" ]; then
            ViashDockerPullElseBuild $VSHD_ID
          else
            ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
            exit 1
          fi
        elif [ "$VSHD_STRAT" == "push" -o "$VSHD_STRAT" == "forcepush" -o "$VSHD_STRAT" == "alwayspush" ]; then
          set +e
          docker push $VSHD_ID
          outPush=$?
          set -e
          if [ $outPush -eq 0 ]; then
            ViashNotice "Container '$VSHD_ID' push succeeded."
          else
            ViashError "Container '$VSHD_ID' push errored."
            exit 1
          fi
        elif [ "$VSHD_STRAT" == "pushifnotpresent" -o "$VSHD_STRAT" == "gentlepush" -o "$VSHD_STRAT" == "maybepush" ]; then
          set +e
          ViashDockerRemoteTagCheck $VSHD_ID
          outCheck=$?
          set -e
          if [ $outCheck -eq 0 ]; then
            ViashNotice "Container '$VSHD_ID' exists, doing nothing."
          else
            ViashNotice "Container '$VSHD_ID' does not yet exist."
            set +e
            docker push $1 > /dev/null 2> /dev/null
            outPush=$?
            set -e
            if [ $outPush -eq 0 ]; then
              ViashNotice "Container '$VSHD_ID' push succeeded."
            else
            ViashError "Container '$VSHD_ID' push errored."
              exit 1
            fi
          fi
        elif [ "$VSHD_STRAT" == "donothing" -o "$VSHD_STRAT" == "meh" ]; then
          ViashNotice "Skipping setup."
        else
          ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
          exit 1
        fi
      }
      
      
      ######## End of helper functions for setting up Docker images for viash ########
      
      # ViashDockerFile: print the dockerfile to stdout
      # return : dockerfile required to run this component
      # examples:
      #   ViashDockerFile
      function ViashDockerfile {
        cat << 'VIASHDOCKER'
      FROM dataintuitive/randpy:r4.0_py3.8_bioc3.12
      
      RUN Rscript -e 'if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")' && \
        Rscript -e 'remotes::install_github(c("dynverse/dyngen@devel"), repos = "https://cran.rstudio.com")'
      
      VIASHDOCKER
      }
      
      # ViashDockerBuild: build a docker container
      # $1              : image identifier with format `[registry/]image[:tag]`
      # exit code $?    : whether or not the image was built
      function ViashDockerBuild {
      
        # create temporary directory to store dockerfile & optional resources in
        tmpdir=$(mktemp -d "$VIASH_TEMP/viashsetupdocker-simulate_dyngen_dataset-XXXXXX")
        function clean_up {
          rm -rf "$tmpdir"
        }
        trap clean_up EXIT
      
        # store dockerfile and resources
        ViashDockerfile > $tmpdir/Dockerfile
        cp -r $VIASH_RESOURCES_DIR/* $tmpdir
      
        # Build the container
        ViashNotice "Running 'docker build -t $@ $tmpdir'"
        set +e
        if [ $VIASH_VERBOSITY -ge 6 ]; then
          docker build -t $@ $tmpdir
        else
          docker build -t $@ $tmpdir &> $tmpdir/docker_build.log
        fi
        out=$?
        set -e
        if [ ! $out -eq 0 ]; then
          ViashError "Error occurred while building the container $@."
          if [ ! $VIASH_VERBOSITY -ge 6 ]; then
            ViashError "Transcript: --------------------------------"
            cat "$tmpdir/docker_build.log"
            ViashError "End of transcript --------------------------"
          fi
          exit 1
        fi
      }
      # ViashAbsolutePath: generate absolute path from relative path
      # borrowed from https://stackoverflow.com/a/21951256
      # $1     : relative filename
      # return : absolute path
      # examples:
      #   ViashAbsolutePath some_file.txt   # returns /path/to/some_file.txt
      #   ViashAbsolutePath /foo/bar/..     # returns /foo
      function ViashAbsolutePath {
        local thePath
        if [[ ! "$1" =~ ^/ ]]; then
          thePath="$PWD/$1"
        else
          thePath="$1"
        fi
        echo "$thePath" | (
          IFS=/
          read -a parr
          declare -a outp
          for i in "${parr[@]}"; do
            case "$i" in
            ''|.) continue ;;
            ..)
              len=${#outp[@]}
              if ((len==0)); then
                continue
              else
                unset outp[$((len-1))]
              fi
              ;;
            *)
              len=${#outp[@]}
              outp[$len]="$i"
            ;;
            esac
          done
          echo /"${outp[*]}"
        )
      }
      # ViashAutodetectMount: auto configuring docker mounts from parameters
      # $1                  : The parameter value
      # returns             : New parameter
      # $VIASH_EXTRA_MOUNTS : Added another parameter to be passed to docker
      # examples:
      #   ViashAutodetectMount /path/to/bar      # returns '/viash_automount/path/to/bar'
      #   ViashAutodetectMountArg /path/to/bar   # returns '-v /path/to:/viash_automount/path/to'
      function ViashAutodetectMount {
        abs_path=$(ViashAbsolutePath "$1")
        if [ -d "$abs_path" ]; then
          mount_source="$abs_path"
          base_name=""
        else
          mount_source=`dirname "$abs_path"`
          base_name=`basename "$abs_path"`
        fi
        mount_target="/viash_automount$mount_source"
        echo "$mount_target/$base_name"
      }
      function ViashAutodetectMountArg {
        abs_path=$(ViashAbsolutePath "$1")
        if [ -d "$abs_path" ]; then
          mount_source="$abs_path"
          base_name=""
        else
          mount_source=`dirname "$abs_path"`
          base_name=`basename "$abs_path"`
        fi
        mount_target="/viash_automount$mount_source"
        echo "-v \"$mount_source:$mount_target\""
      }
      # ViashExtractFlags: Retain leading flag
      # $1     : string with a possible leading flag
      # return : leading flag
      # examples:
      #   ViashExtractFlags --foo=bar  # returns --foo
      function ViashExtractFlags {
        echo $1 | sed 's/=.*//'
      }
      # initialise variables
      VIASH_EXTRA_MOUNTS=''
      
      # initialise array
      VIASH_POSITIONAL_ARGS=''
      
      while [[ $# -gt 0 ]]; do
          case "$1" in
              -h|--help)
                  ViashHelp
                  exit
                  ;;
              -v|--verbose)
                  let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
                  shift 1
                  ;;
              -vv)
                  let "VIASH_VERBOSITY=VIASH_VERBOSITY+2"
                  shift 1
                  ;;
              --verbosity)
                  VIASH_VERBOSITY="$2"
                  shift 2
                  ;;
              --verbosity=*)
                  VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
                  shift 1
                  ;;
              --version)
                  echo "simulate_dyngen_dataset main_build"
                  exit
                  ;;
              --id)
                  VIASH_PAR_ID="$2"
                  shift 2
                  ;;
              --id=*)
                  VIASH_PAR_ID=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --output_rna)
                  VIASH_PAR_OUTPUT_RNA="$2"
                  shift 2
                  ;;
              --output_rna=*)
                  VIASH_PAR_OUTPUT_RNA=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --output_mod2)
                  VIASH_PAR_OUTPUT_MOD2="$2"
                  shift 2
                  ;;
              --output_mod2=*)
                  VIASH_PAR_OUTPUT_MOD2=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --plot)
                  VIASH_PAR_PLOT="$2"
                  shift 2
                  ;;
              --plot=*)
                  VIASH_PAR_PLOT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              -p)
                  VIASH_PAR_PLOT="$2"
                  shift 2
                  ;;
              --backbone)
                  VIASH_PAR_BACKBONE="$2"
                  shift 2
                  ;;
              --backbone=*)
                  VIASH_PAR_BACKBONE=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              -b)
                  VIASH_PAR_BACKBONE="$2"
                  shift 2
                  ;;
              --num_cells)
                  VIASH_PAR_NUM_CELLS="$2"
                  shift 2
                  ;;
              --num_cells=*)
                  VIASH_PAR_NUM_CELLS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --num_genes)
                  VIASH_PAR_NUM_GENES="$2"
                  shift 2
                  ;;
              --num_genes=*)
                  VIASH_PAR_NUM_GENES=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --num_simulations)
                  VIASH_PAR_NUM_SIMULATIONS="$2"
                  shift 2
                  ;;
              --num_simulations=*)
                  VIASH_PAR_NUM_SIMULATIONS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --census_interval)
                  VIASH_PAR_CENSUS_INTERVAL="$2"
                  shift 2
                  ;;
              --census_interval=*)
                  VIASH_PAR_CENSUS_INTERVAL=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --ssa_tau)
                  VIASH_PAR_SSA_TAU="$2"
                  shift 2
                  ;;
              --ssa_tau=*)
                  VIASH_PAR_SSA_TAU=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --store_chromatin)
                  VIASH_PAR_STORE_CHROMATIN=true
                  shift 1
                  ;;
              -chromatin)
                  VIASH_PAR_STORE_CHROMATIN=true
                  shift 1
                  ;;
              --store_protein)
                  VIASH_PAR_STORE_PROTEIN=true
                  shift 1
                  ;;
              -protein)
                  VIASH_PAR_STORE_PROTEIN=true
                  shift 1
                  ;;
              --num_proteins)
                  VIASH_PAR_NUM_PROTEINS="$2"
                  shift 2
                  ;;
              --num_proteins=*)
                  VIASH_PAR_NUM_PROTEINS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --num_threads)
                  VIASH_PAR_NUM_THREADS="$2"
                  shift 2
                  ;;
              --num_threads=*)
                  VIASH_PAR_NUM_THREADS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --cache_dir)
                  VIASH_PAR_CACHE_DIR="$2"
                  shift 2
                  ;;
              --cache_dir=*)
                  VIASH_PAR_CACHE_DIR=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              ---setup)
                  ViashDockerSetup 'openproblems/common_datasets_simulate_dyngen_dataset:main_build' "$2"
                  exit 0
                  ;;
              ---setup=*)
                  ViashDockerSetup 'openproblems/common_datasets_simulate_dyngen_dataset:main_build' "$(ViashRemoveFlags "$1")"
                  exit 0
                  ;;
              ---dockerfile)
                  ViashDockerfile
                  exit 0
                  ;;
              ---v|---volume)
                  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS -v "$2""
                  shift 2
                  ;;
              ---volume=*)
                  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS -v $(ViashRemoveFlags "$2")"
                  shift 1
                  ;;
              ---debug)
                  ViashNotice "+ docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t openproblems/common_datasets_simulate_dyngen_dataset:main_build"
                  docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t openproblems/common_datasets_simulate_dyngen_dataset:main_build
                  exit 0
                  ;;
              *)  # positional arg or unknown option
                  # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
                  VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
                  shift # past argument
                  ;;
          esac
      done
      
      # parse positional parameters
      eval set -- $VIASH_POSITIONAL_ARGS
      
      
      
      # check whether required parameters exist
      if [ -z "$VIASH_PAR_ID" ]; then
        ViashError '--id' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_OUTPUT_RNA" ]; then
        ViashError '--output_rna' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_OUTPUT_MOD2" ]; then
        ViashError '--output_mod2' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_PLOT" ]; then
        ViashError '--plot' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_BACKBONE" ]; then
        VIASH_PAR_BACKBONE="bifurcating"
      fi
      if [ -z "$VIASH_PAR_NUM_CELLS" ]; then
        VIASH_PAR_NUM_CELLS="100"
      fi
      if [ -z "$VIASH_PAR_NUM_GENES" ]; then
        VIASH_PAR_NUM_GENES="100"
      fi
      if [ -z "$VIASH_PAR_NUM_SIMULATIONS" ]; then
        VIASH_PAR_NUM_SIMULATIONS="32"
      fi
      if [ -z "$VIASH_PAR_CENSUS_INTERVAL" ]; then
        VIASH_PAR_CENSUS_INTERVAL="4.0"
      fi
      if [ -z "$VIASH_PAR_SSA_TAU" ]; then
        VIASH_PAR_SSA_TAU="0.008333"
      fi
      if [ -z "$VIASH_PAR_STORE_CHROMATIN" ]; then
        VIASH_PAR_STORE_CHROMATIN="false"
      fi
      if [ -z "$VIASH_PAR_STORE_PROTEIN" ]; then
        VIASH_PAR_STORE_PROTEIN="false"
      fi
      if [ -z "$VIASH_PAR_NUM_PROTEINS" ]; then
        VIASH_PAR_NUM_PROTEINS="50"
      fi
      if [ -z "$VIASH_PAR_NUM_THREADS" ]; then
        VIASH_PAR_NUM_THREADS="1"
      fi
      
      ViashDockerSetup 'openproblems/common_datasets_simulate_dyngen_dataset:main_build' ifneedbepullelsecachedbuild
      
      # detect volumes from file arguments
      if [ ! -z "$VIASH_PAR_OUTPUT_RNA" ]; then
        VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_OUTPUT_RNA")"
        VIASH_PAR_OUTPUT_RNA=$(ViashAutodetectMount "$VIASH_PAR_OUTPUT_RNA")
      fi
      if [ ! -z "$VIASH_PAR_OUTPUT_MOD2" ]; then
        VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_OUTPUT_MOD2")"
        VIASH_PAR_OUTPUT_MOD2=$(ViashAutodetectMount "$VIASH_PAR_OUTPUT_MOD2")
      fi
      if [ ! -z "$VIASH_PAR_PLOT" ]; then
        VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_PLOT")"
        VIASH_PAR_PLOT=$(ViashAutodetectMount "$VIASH_PAR_PLOT")
      fi
      if [ ! -z "$VIASH_PAR_CACHE_DIR" ]; then
        VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_CACHE_DIR")"
        VIASH_PAR_CACHE_DIR=$(ViashAutodetectMount "$VIASH_PAR_CACHE_DIR")
      fi
      
      # Always mount the resource directory
      VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_RESOURCES_DIR")"
      VIASH_RESOURCES_DIR=$(ViashAutodetectMount "$VIASH_RESOURCES_DIR")
      
      # Always mount the VIASH_TEMP directory
      VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_TEMP")"
      VIASH_TEMP=$(ViashAutodetectMount "$VIASH_TEMP")
      
      # change file ownership
      function viash_perform_chown {
        
        if [ ! -z "$VIASH_PAR_OUTPUT_RNA" ]; then
          eval docker run --entrypoint=chown -i --rm $VIASH_EXTRA_MOUNTS openproblems/common_datasets_simulate_dyngen_dataset:main_build "$(id -u):$(id -g)" --silent --recursive "$VIASH_PAR_OUTPUT_RNA"
        fi
        if [ ! -z "$VIASH_PAR_OUTPUT_MOD2" ]; then
          eval docker run --entrypoint=chown -i --rm $VIASH_EXTRA_MOUNTS openproblems/common_datasets_simulate_dyngen_dataset:main_build "$(id -u):$(id -g)" --silent --recursive "$VIASH_PAR_OUTPUT_MOD2"
        fi
        if [ ! -z "$VIASH_PAR_PLOT" ]; then
          eval docker run --entrypoint=chown -i --rm $VIASH_EXTRA_MOUNTS openproblems/common_datasets_simulate_dyngen_dataset:main_build "$(id -u):$(id -g)" --silent --recursive "$VIASH_PAR_PLOT"
        fi
      }
      trap viash_perform_chown EXIT
      
      
      cat << VIASHEOF | eval docker run --entrypoint=bash -i --rm $VIASH_EXTRA_MOUNTS openproblems/common_datasets_simulate_dyngen_dataset:main_build
      set -e
      tempscript=\$(mktemp "$VIASH_TEMP/viash-run-simulate_dyngen_dataset-XXXXXX")
      function clean_up {
        rm "\$tempscript"
      }
      trap clean_up EXIT
      cat > "\$tempscript" << 'VIASHMAIN'
      cat("Loading dependencies\\n")
      options(tidyverse.quiet = TRUE)
      library(tidyverse)
      library(dyngen, quietly = TRUE, warn.conflicts = FALSE)
      library(Matrix, quietly = TRUE, warn.conflicts = FALSE)
      requireNamespace("anndata", quietly = TRUE)
      
      
      ## VIASH START
      # The following code has been auto-generated by Viash.
      par <- list(
        "id" = $( if [ ! -z ${VIASH_PAR_ID+x} ]; then echo "'$VIASH_PAR_ID'"; else echo NULL; fi ),
        "output_rna" = $( if [ ! -z ${VIASH_PAR_OUTPUT_RNA+x} ]; then echo "'$VIASH_PAR_OUTPUT_RNA'"; else echo NULL; fi ),
        "output_mod2" = $( if [ ! -z ${VIASH_PAR_OUTPUT_MOD2+x} ]; then echo "'$VIASH_PAR_OUTPUT_MOD2'"; else echo NULL; fi ),
        "plot" = $( if [ ! -z ${VIASH_PAR_PLOT+x} ]; then echo "'$VIASH_PAR_PLOT'"; else echo NULL; fi ),
        "backbone" = $( if [ ! -z ${VIASH_PAR_BACKBONE+x} ]; then echo "'$VIASH_PAR_BACKBONE'"; else echo NULL; fi ),
        "num_cells" = $( if [ ! -z ${VIASH_PAR_NUM_CELLS+x} ]; then echo "as.integer($VIASH_PAR_NUM_CELLS)"; else echo NULL; fi ),
        "num_genes" = $( if [ ! -z ${VIASH_PAR_NUM_GENES+x} ]; then echo "as.integer($VIASH_PAR_NUM_GENES)"; else echo NULL; fi ),
        "num_simulations" = $( if [ ! -z ${VIASH_PAR_NUM_SIMULATIONS+x} ]; then echo "as.integer($VIASH_PAR_NUM_SIMULATIONS)"; else echo NULL; fi ),
        "census_interval" = $( if [ ! -z ${VIASH_PAR_CENSUS_INTERVAL+x} ]; then echo "as.numeric($VIASH_PAR_CENSUS_INTERVAL)"; else echo NULL; fi ),
        "ssa_tau" = $( if [ ! -z ${VIASH_PAR_SSA_TAU+x} ]; then echo "as.numeric($VIASH_PAR_SSA_TAU)"; else echo NULL; fi ),
        "store_chromatin" = $( if [ ! -z ${VIASH_PAR_STORE_CHROMATIN+x} ]; then echo "as.logical(toupper('$VIASH_PAR_STORE_CHROMATIN'))"; else echo NULL; fi ),
        "store_protein" = $( if [ ! -z ${VIASH_PAR_STORE_PROTEIN+x} ]; then echo "as.logical(toupper('$VIASH_PAR_STORE_PROTEIN'))"; else echo NULL; fi ),
        "num_proteins" = $( if [ ! -z ${VIASH_PAR_NUM_PROTEINS+x} ]; then echo "as.integer($VIASH_PAR_NUM_PROTEINS)"; else echo NULL; fi ),
        "num_threads" = $( if [ ! -z ${VIASH_PAR_NUM_THREADS+x} ]; then echo "as.integer($VIASH_PAR_NUM_THREADS)"; else echo NULL; fi ),
        "cache_dir" = $( if [ ! -z ${VIASH_PAR_CACHE_DIR+x} ]; then echo "'$VIASH_PAR_CACHE_DIR'"; else echo NULL; fi )
      )
      
      resources_dir = "$VIASH_RESOURCES_DIR"
      
      ## VIASH END
      
      if (par\$store_protein == par\$store_chromatin) {
        cat("Warning: Strictly pass one of --store_protein and --store_chromatin, not neither or both.\\n")
      }
      
      cat("Creating dyngen backbone\\n")
      backbones <- list_backbones()
      
      if (is.null(par\$backbone)) {
        par\$backbone <- sample(names(backbones), 1)
      }
      
      backbone <- backbones[[par\$backbone]]()
      
      cat("Generating regulatory network\\n")
      num_tfs <- nrow(backbone\$module_info)
      num_targets <- ceiling(0.8 * (par\$num_genes - num_tfs))
      num_hks <- par\$num_genes - num_tfs - num_targets
      num_cells_train <- round(par\$num_cells * .66)
      num_cells_test <- par\$num_cells - num_cells_train
      
      model_init <- initialise_model(
        backbone = backbone,
        num_cells = num_cells_train,
        num_tfs = num_tfs,
        num_targets = num_targets,
        num_hks = num_hks,
        simulation_params = simulation_default(
          census_interval = par\$census_interval,
          ssa_algorithm = ssa_etl(tau = par\$ssa_tau),
          experiment_params = simulation_type_wild_type(
            num_simulations = round(0.66*par\$num_simulations)
          ),
          compute_cellwise_grn = par\$store_chromatin
        ),
        num_cores = par\$num_threads,
        verbose = FALSE,
        download_cache_dir = par\$cache_dir
      ) %>%
        generate_tf_network() %>%
        generate_feature_network()
      
      cat("Running simulations for training cells\\n")
      model_train <-
        model_init %>%
        generate_kinetics() %>%
        generate_gold_standard() %>%
        generate_cells() %>%
        generate_experiment()
      
      cat("Running simulations for test cells\\n")
      model_init\$num_cells <-
        model_init\$numbers\$num_cells <-
        num_cells_test
      model_init\$simulation_params\$experiment_params <-
        simulation_type_wild_type(round(0.37*par\$num_simulations))
      model_test <-
        model_init %>%
        generate_kinetics() %>% # use different kinetics
        generate_gold_standard() %>%
        generate_cells() %>%
        generate_experiment()
      
      cat("Combine simulations into one dataset\\n")
      model <- combine_models(
        list(
          batch1 = model_train, 
          batch2 = model_test
        ),
        duplicate_gold_standard = FALSE
      )
      dataset <- as_list(model)
      
      # verify batch effects
      # dat <- as_dyno(model)
      # grouping <- dat\$cell_info %>% select(cell_id, model) %>% deframe()
      # dynplot::plot_dimred(dat, grouping = grouping)
      cat("Create RNA dataset\\n")
      celltypes <- dataset\$milestone_percentages %>%
        group_by(cell_id) %>%
        slice(which.max(percentage)) %>%
        ungroup() %>% 
        select(cell_id, cell_type = milestone_id)
      obs <- dataset\$cell_info %>% 
        left_join(celltypes, by = "cell_id") %>%
        rename(batch = model) %>%
        column_to_rownames("cell_id")
      var <- dataset\$feature_info %>% 
        select(feature_id, module_id, basal, burn, independence, color, is_tf, is_hk) %>% 
        column_to_rownames("feature_id")
      ad_mod1 <- anndata::AnnData(
        X = dataset\$counts,
        obs = obs,
        var = var %>% mutate(feature_types = "GEX"),
        uns = list(
          dataset_id = par\$id
        )
      )
      
      if (par\$store_protein) {
        cat("Processing Antibody data\\n")
        # construct AbSeq-like data from protein counts
        # TODO: use real AbSeq data to map distributions
        counts_protein <- dataset\$counts_protein
        var_protein <- var %>% mutate(feature_types = "ADT")
      
        # sample 50 genes
        if (ncol(counts_protein) > par\$num_proteins) {
          sample_genes <- sample.int(ncol(counts_protein), par\$num_proteins)
          counts_protein <- counts_protein[,sample_genes, , drop = FALSE]
          var_protein <- var_protein[sample_genes, , drop = FALSE]
        }
      
        ad_mod2 <- anndata::AnnData(
          X = counts_protein,
          obs = obs,
          var = var_protein,
          uns = list(
            dataset_id = par\$id
          )
        )
      }
      
      if (par\$store_chromatin) {
        cat("Processing ATAC data\\n")
        # constuct atac-like data from single cell regulatory network
        # TODO: use real atac data to map distributions
        mat <- dataset\$regulatory_network_sc %>%
          mutate(
            edge = factor(paste0(as.character(regulator), "->", as.character(target)))
          )
        regsc <- Matrix::sparseMatrix(
          i = as.integer(mat\$cell_id),
          j = as.integer(mat\$edge),
          x = pmax(mat\$strength, 0)*100
        )
        rownames(regsc) <- dataset\$cell_ids
        colnames(regsc) <- paste0("region_", seq_len(ncol(regsc)))
        var_atac <- data.frame(
          row.names = colnames(regsc),
          feature_types = rep("ATAC", ncol(regsc))
        )
      
        ad_mod2 <- anndata::AnnData(
          X = regsc,
          obs = obs,
          var = var_atac,
          uns = list(
            dataset_id = par\$id
          )
        )
      }
      
      cat("Write h5ad files\\n")
      ad_mod1\$write_h5ad(par\$output_rna, compression = "gzip")
      ad_mod2\$write_h5ad(par\$output_mod2, compression = "gzip")
      
      if (!is.null(par\$plot)) {
        cat("Storing summary plot\\n")
        g <- plot_summary(model)
        ggsave(par\$plot, g, width = 20, height = 16)
      }
      VIASHMAIN
      PATH="$VIASH_RESOURCES_DIR:\$PATH"
      
      Rscript "\$tempscript"
      
      VIASHEOF
      

    dest: "simulate_dyngen_dataset"
    is_executable: true
  description: "Generate a synthetic dataset using the standard dyngen simulation\
    \ workflow.\nFor more advanced usage to get more control over the outputted dataset,\
    \ use the\nR package. More documentation can be found at https://dyngen.dynverse.org.\n"
  tests:
  - type: "r_script"
    path: "test.R"
    is_executable: true
  info:
    doi: "10.1038/s41467-021-24152-2"
    url: "https://dyngen.dynverse.org"
platform:
  type: "docker"
  id: "docker"
  image: "dataintuitive/randpy:r4.0_py3.8_bioc3.12"
  target_registry: "openproblems"
  namespace_separator: "_"
  resolve_volume: "Automatic"
  chown: true
  setup_strategy: "ifneedbepullelsecachedbuild"
  privileged: false
  setup:
  - type: "r"
    packages: []
    cran: []
    bioc: []
    git: []
    github:
    - "dynverse/dyngen@devel"
    gitlab: []
    bitbucket: []
    svn: []
    url: []
    script: []
    bioc_force_install: false
    oType: "r"
platforms: []
info:
  config: "src/common/datasets/simulate_dyngen_dataset/config.vsh.yaml"
  platform: "docker"
  output: "target/docker/common_datasets/simulate_dyngen_dataset"
  executable: "target/docker/common_datasets/simulate_dyngen_dataset/simulate_dyngen_dataset"
  viash_version: "0.5.1"
  git_commit: "f4a16f243d56c86a7abb2ec689401b00a4e8ca79"
  git_remote: "https://github.com/openproblems-bio/neurips2021_multimodal_viash"
